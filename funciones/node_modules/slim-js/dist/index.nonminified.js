var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils.js
var utils_exports = {};
__export(utils_exports, {
  NOOP: () => NOOP,
  createFunction: () => createFunction,
  dashToCamel: () => dashToCamel,
  findCtx: () => findCtx,
  forceUpdate: () => forceUpdate,
  isForcedUpdate: () => isForcedUpdate,
  lazyQueue: () => lazyQueue,
  markFlush: () => markFlush,
  memoize: () => memoize,
  normalize: () => normalize,
  requestIdleCallback: () => requestIdleCallback
});

// src/internals.js
var S = Symbol;
var block = S("block");
var repeatCtx = S("repeat");
var requestIdleCallback = window.requestIdleCallback || ((cb, ...args) => setTimeout(cb));
var internals = S("internals");
var CREATE = S();
var RENDER = S();
var ADDED = S();
var REMOVED = S();
var debug = S();
var index = S();

// src/utils.js
var forceUpdateMap = new WeakSet();
var flushMap = new WeakMap();
function forceUpdate(target, ...keys) {
  const props = [...arguments].slice(1);
  const flush = flushMap.get(target);
  if (!flush) {
    return console.error("Flush error");
  }
  forceUpdateMap.add(target);
  if (props.length) {
    flush(...props);
  } else {
    flush();
  }
  requestAnimationFrame(() => forceUpdateMap.delete(target));
}
var findCtx = (t) => {
  while (t && !t[repeatCtx]) {
    t = t.parentElement;
  }
  return t?.[repeatCtx];
};
var isForcedUpdate = (t) => forceUpdateMap.has(t);
var markFlush = (t, flush) => flushMap.set(t, flush);
var d2c = /-[a-z]/g;
var dashToCamel = (dash) => dash.indexOf("-") < 0 ? dash : dash.replace(d2c, (m) => m[1].toUpperCase());
var dlPolyfill = { timeRemaining: () => true };
var lazyQueue = (queue, timeout = 20, onComplete = NOOP) => {
  const opts = { timeout };
  const iterator = queue[Symbol.iterator]();
  let task = iterator.next();
  const run = () => requestIdleCallback(execOne, opts);
  const execOne = (deadline = dlPolyfill) => {
    while (deadline.timeRemaining() && !task.done) {
      task.value();
      task = iterator.next();
    }
    if (deadline?.didTimeout && !task.done) {
      task.value();
      task = iterator.next();
    }
    if (!task.done) {
      run();
    } else {
      onComplete();
    }
  };
  run();
};
var normalize = (html) => html.replace(/\n/g, "").replace(/[\t ]+\</g, "<").replace(/\>[\t ]+\</g, "><").replace(/\>[\t ]+$/g, ">");
var memoize = (fn) => {
  const memoizeCache = {};
  return (str) => memoizeCache[str] || (memoizeCache[str] = fn(str));
};
var fnCache = {};
var createFunction = (...args) => {
  const key = args.join("$");
  return fnCache[key] || (fnCache[key] = new Function(...args));
};
var NOOP = () => void 0;

// src/expression.js
var ITEM = Symbol();
var stripCurlies = /(\{\{([^\{|^\}]+)\}\})/gi;
var rx = /(this\.[\w+|\d*]*)+/gi;
var ix = /item(\.[\w+|\d*]*)*/gi;
var doParse = (expression = "") => {
  const paths = [];
  let match = null;
  rx.lastIndex = ix.lastIndex = 0;
  while (match = rx.exec(expression))
    paths.push(match[1].split(".")[1]);
  if (ix.test(expression))
    paths.push(ITEM);
  return {
    paths,
    expressions: paths.length ? expression.match(stripCurlies) || [] : []
  };
};
var parse = memoize(doParse);

// src/enhance.js
var addons = Symbol();
var Registry = class {
  constructor() {
    this[addons] = [];
  }
  add(addon, priority = false) {
    priority ? this[addons].unshift(addon) : this[addons].push(addon);
  }
  getAll() {
    return [...this[addons]];
  }
};
var PluginRegistryClass = class extends Registry {
  exec(phase, target) {
    this[addons].forEach((addon) => addon(phase, target));
  }
};
var DirectiveRegistry = new Registry();
var PluginRegistry = new PluginRegistryClass();

// src/dom.js
var emptyArray = [];
var emptyObject = {};
var ABORT = "abort";
var cons = console;
var logError = (title, message, ...info) => Component[debug] && (cons.group(title), cons.error(message), cons.info(...info), cons.groupEnd());
var expressionToJS = memoize((str) => "`" + str.replaceAll("{{", "${").replaceAll("}}", "}") + "`");
var walkerFilter = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;
var createWalker = (target) => document.createTreeWalker(target, walkerFilter);
var type = (o, t) => typeof o === t;
var bindMap = new WeakMap();
var extract = (ctx) => type(ctx, "function") ? ctx() : ctx;
var createBind = (source, target, property, execution) => {
  let propToTarget = bindMap.get(source) || bindMap.set(source, {}).get(source);
  if (!propToTarget[property]) {
    const oSet = (Object.getOwnPropertyDescriptor(source, property) || emptyObject).set;
    let value = source[property];
    Object.defineProperty(source, property, {
      get: () => value,
      set: (v) => {
        if (v !== value || type(v, "object")) {
          value = v;
          if (oSet) {
            oSet(v);
          }
          runBinding(source, property, value);
        }
      }
    });
  }
  (propToTarget[property] = propToTarget[property] || new Set()).add(target);
  let meta = target[internals] = target[internals] || {};
  if (type(property, "symbol"))
    return NOOP;
  (meta[property] = meta[property] || new Set()).add(execution);
  return () => {
    meta[property].delete(execution);
  };
};
var runOneBind = (meta, property, resolvedValue) => {
  (meta[property] || emptyArray).forEach((target) => {
    const value = target[repeatCtx] || resolvedValue;
    target[internals][property].forEach((fn) => fn(value));
  });
};
var runBinding = (source, property, value) => {
  let propToTarget = bindMap.get(source) || bindMap.set(source, {}).get(source);
  if (property !== "*") {
    runOneBind(propToTarget, property, value);
  } else {
    Object.keys(propToTarget).forEach((key) => runOneBind(propToTarget, key, source[key]));
  }
};
var removeBindings = (source, target, property = "*") => {
  let propToTarget = bindMap.get(source) || emptyObject;
  if (property === "*") {
    Object.keys(propToTarget).forEach((key) => removeBindings(source, target, key));
    return;
  }
  let meta = propToTarget[property];
  if (meta) {
    const localWalker = createWalker(target);
    let node = localWalker.currentNode;
    while (node) {
      meta.delete(node);
      node = localWalker.nextNode();
    }
  }
};
var processDOM = (scope, dom) => {
  const unbinds = new Set();
  const bounds = new Set();
  const pendingAttributesToRemove = new Set();
  const pendingNodesToRemove = new Set();
  const directives = DirectiveRegistry.getAll();
  const walker = createWalker(dom);
  let currentNode = walker.currentNode || walker.nextNode();
  for (; currentNode; currentNode = walker.nextNode()) {
    const currentNodeRef = currentNode;
    currentNode.nodeType;
    currentNode.nodeValue;
    currentNode.addEventListener;
    const nodeName = currentNode.nodeName;
    const defaultContext = () => findCtx(currentNodeRef);
    if (currentNode.nodeType === Node.ELEMENT_NODE) {
      const targetNode = currentNode;
      if (nodeName.includes("-") && type(targetNode[block], "undefined")) {
        targetNode[block] = true;
        requestAnimationFrame(() => targetNode[block] = false);
      }
      if (targetNode[block] === ABORT) {
        continue;
      }
      const attributes = Array.from(targetNode.attributes);
      let i = 0, l = attributes.length;
      a_l:
        for (i; i < l; i++) {
          const attr = attributes[i];
          const attrName = attr.nodeName;
          const attrValue = attr.nodeValue || "";
          if (currentNode[block] === ABORT) {
            break a_l;
          }
          const expression = attrValue.trim();
          const userCode = expression.slice(0, 2) === "{{" && expression.slice(-2) === "}}" ? expression.slice(2, -2) : expression;
          const paths = ~expression.indexOf("{{") ? parse(userCode).paths : emptyArray;
          d_l:
            for (const directive of directives) {
              if (currentNode[block] === ABORT) {
                break d_l;
              }
              if (directive.attribute(attr, attrName, attrValue)) {
                const {
                  update: invocation,
                  removeAttribute,
                  removeNode
                } = directive.process({
                  attribute: attr,
                  attributeName: attrName,
                  attributeValue: attrValue,
                  context: defaultContext,
                  expression: userCode,
                  props: paths,
                  scopeNode: scope,
                  targetNode,
                  targetNodeName: nodeName
                });
                if (removeAttribute) {
                  pendingAttributesToRemove.add(attr);
                }
                if (removeNode) {
                  pendingNodesToRemove.add(targetNode);
                }
                if (invocation) {
                  const fn = directive.noExecution ? NOOP : createFunction("item", `return ${userCode}`);
                  const update = (altContext = defaultContext()) => {
                    try {
                      const value = fn === NOOP ? void 0 : fn.call(scope, extract(altContext));
                      invocation(value, isForcedUpdate(scope));
                    } catch (err) {
                      logError(`Directive Error ${attrName}`, err.message, `Expression: ${userCode}`, "Node", targetNode);
                    }
                  };
                  bounds.add(update);
                  paths.forEach((path) => {
                    unbinds.add(createBind(scope, currentNode, path, update));
                  });
                }
              }
            }
        }
    } else if (currentNode.nodeType === Node.TEXT_NODE) {
      const expression = currentNode.textContent;
      if (!~expression.indexOf("{{"))
        continue;
      const targetNode = currentNode;
      const { paths: oPaths } = parse(expression);
      const raw = expressionToJS(expression);
      const fn = createFunction("item", `return ${raw}`);
      const oUpdate = (altContext = defaultContext()) => {
        try {
          targetNode.nodeValue = fn.call(scope, altContext);
        } catch (err) {
          logError(`Expression error: ${expression}`, err.message, "Node", targetNode.parentElement);
        }
      };
      bounds.add(oUpdate);
      oPaths.forEach((path) => unbinds.add(createBind(scope, currentNode, path, oUpdate)));
    }
  }
  pendingNodesToRemove.forEach((e) => e.remove());
  if (!Component[debug]) {
    pendingAttributesToRemove.forEach((attr) => {
      try {
        attr.ownerElement.removeAttribute(attr.nodeName);
      } catch (e) {
      }
    });
  }
  return {
    flush: (...props) => {
      if (props.length) {
        props.forEach((key) => runBinding(scope, key));
      } else {
        runBinding(scope, "*");
      }
    },
    clear: () => lazyQueue(unbinds),
    bounds
  };
};

// src/component.js
var S2 = Symbol;
var LIFECYCLE_CREATE = S2();
var LIFECYCLE_RENDER = S2();
var Component = class extends HTMLElement {
  static element(tag, template, base = class extends Slim {
  }) {
    base.template = template;
    customElements.define(tag, base);
  }
  constructor() {
    super();
    this[LIFECYCLE_CREATE]();
  }
  onBeforeCreated() {
  }
  onCreated() {
  }
  onAdded() {
  }
  onRemoved() {
  }
  onRender() {
  }
  connectedCallback() {
    this.onAdded();
    PluginRegistry.exec(ADDED, this);
  }
  disconnectedCallback() {
    this.onRemoved();
    PluginRegistry.exec(REMOVED, this);
  }
  [LIFECYCLE_CREATE]() {
    if (this[block] === "abort")
      return;
    if (this[block]) {
      return requestAnimationFrame(() => this[LIFECYCLE_CREATE]());
    }
    this.onBeforeCreated();
    if (this.constructor.useShadow && !this.shadowRoot) {
      this.attachShadow({ mode: "open" });
    }
    PluginRegistry.exec(CREATE, this);
    this[LIFECYCLE_RENDER]();
  }
  [LIFECYCLE_RENDER]() {
    const template = normalize(this.constructor.template);
    if (template) {
      const tpl = document.createElement("template");
      tpl.innerHTML = template;
      Promise.resolve().then(() => {
        const { flush } = processDOM(this, tpl.content);
        markFlush(this, flush);
        flush();
        this.onCreated();
        PluginRegistry.exec(RENDER, this);
        (this.shadowRoot || this).appendChild(tpl.content);
        this.onRender();
      });
    }
  }
};
__publicField(Component, "template", "");
__publicField(Component, "useShadow", true);

// src/index.js
var Phase = {
  ADDED,
  CREATE,
  RENDER,
  REMOVED
};
var Internals = {
  repeatCtx,
  internals,
  block,
  index,
  requestIdleCallback
};
Window.prototype.Slim = Component;
export {
  Component,
  DirectiveRegistry,
  Internals,
  Phase,
  PluginRegistry,
  Component as Slim,
  utils_exports as Utils,
  createBind,
  processDOM,
  removeBindings
};
